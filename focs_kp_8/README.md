# Отчёт по курсовой работе №8 по курсу «Языки и методы программирования»

<b>Студент группы:</b> <ins>М8О-108Б-22, Ибрагимов Далгат Магомедалиевич, № по списку 8</ins>

<b>Контакты e-mail:</b> <ins>doly2004e@yandex.ru<ins>

<b>Работа выполнена:</b> «25» <ins>мая</ins> <ins>2023</ins>

<b>Преподаватель:</b> <ins>асп. каф.806 Сахарин Никита Александрович</ins>

<b>Отчет сдан</b> «27» <ins>июня</ins> <ins>2023</ins> г., <b>итоговая оценка</b> <ins>3</ins>

<b>Подпись преподавателя:</b> ___________

## 1. Тема
Линейные списки

## 2. Цель работы
Составить и отладить программу на языке Си для обработки линейного списа заданной организации с отображением списка на динамические структуры, содержащего узлы типа int. Навигацию по списку следует реализовать с применением итераторов.

## 3. Задание
Тип элемента списка: литерный

Вид списка: линейный двунаправленный

Нестандартное действие: удалить k элементов с конца списка(если в списке меньше k элементов - не менять его)

## 4. Оборудование
<b>Процессор:</b> AMD Ryzen 5 5600H (12) @ 3.600GHz<br/>
<b>ОП:</b> 32GiB 3200 MHz LPDDR4<br/>
<b>SSD:</b> 512 GiB<br/>
<b>Адрес:</b> <br/>
<b>Монитор:</b> 23.5-дюймовый (1920 х 1080)<br/>
<b>Графика:</b>AMD Radeon™ RX 6600M 2177 MHz 8GiB GDDR6<br/>

## 5. Программное обеспечение:
<b>Слой совместимости для запуска Linux-приложений в ОС Windows:</b> WSL2 5.10.102.1<br/>
<b>Операционная система семейства UNIX:</b> Ubuntu 20.04 LTS GNU/Linux 5.10.16.3-microsoft-standard-WSL2 x86_64<br/>
<b>Интерпретатор команд:</b> bash версия 5.1.16<br/>
<b>Система программирования:</b> GNU <br/>
<b>Редактор текстов:</b> Visual Studio Code<br/>
<b>Утилиты операционной системы:</b> cd, pwd, ls, cp, mv, mkdir, rmdir, cat, man, ps, rm<br/>
<b>Прикладные системы и программы:</b> gnuplot<br/>
<b>Местонахождение и имена файлов программ и данных на домашнем компьютере:</b> /home/lockr<br/>

## 6. Идея, метод, алгоритм решения задачи
Будут реализоаны следующие функции:
    void pushFront(Node** head, char data);
    void pushBack(Node** head, char data);
    void pushIndex(Node** head, char data, int k);
    void deleteBack(Node** head);
    void deleteFront(Node** head);
    void deleteIndex(Node** head, int k);
    void func(Node** head, int k);
    void printList(Node* head);
    void destroy(Node* head);
    int sizeList(Node* head);

## 7. Сценарий выполнения работы
list.h
```
#ifndef list_h
#define list_h

#include <stdio.h>
#include <stdlib.h>

typedef struct node { //структура списка
    char data; //литера
    struct node* prev; //указатель на предыдущий
    struct node* next; //указатель на следующий
} Node;

void pushFront(Node** head, char data);
void pushBack(Node** head, char data);
void pushIndex(Node** head, char data, int k);
void deleteBack(Node** head);
void deleteFront(Node** head);
void deleteIndex(Node** head, int k);
void func(Node** head, int k);
void printList(Node* head);
void destroy(Node* head);
int sizeList(Node* head);

#endif
```
list.c

```
#include "list.h"

void pushFront(Node** head, char data) { //функция добавления спереди
    Node* newNode = (Node*)malloc(sizeof(Node)); //выделяем память
    newNode->data = data; //присваиваем значение литеры
    if (*head == NULL) { //если "голова" пустая
        *head = newNode; //добавленный элемент - голова списка
        newNode->prev = newNode->next = newNode; //ссылка на самого себя
    } else { // иначе
        Node* last = (*head)->prev; 
        newNode->prev = last; //предыдущий нового элемента - предыдущий у головы
        newNode->next = *head; //некст - head
        (*head)->prev = newNode; //связываем голову и новый элемент сзади
        last->next = newNode; //связываем некст и новый
        *head = newNode;
    }
}

void pushIndex(Node** head, char data, int k) {
    int size = sizeList(*head);
    if (k > size || k < 0) {
        printf("Выход за границы списка!\n");
        return;
    }
    Node* newNode = (Node*)malloc(sizeof(Node));//выделяем память
    newNode->data = data;//присваиваем значение литеры
    Node* current = *head;
    if (*head == NULL && k == 0) {
        *head = newNode;
        current = newNode;
        newNode->next = newNode;
        newNode->prev = newNode;
    } else if (k == 0) {
        Node* last = current->prev;
        last->next = newNode;
        newNode->prev = last;
        current->prev = newNode;
        newNode->next = current;
        *head = newNode;
    } else {    
        for (int i = 0; i < k; i++) { // движемся до k
            current = current->next;
        }
        Node* left = current->prev;
        left->next = newNode;
        newNode->prev = left;
        current->prev = newNode;
        newNode->next = current;
    }
}

void deleteIndex(Node** head, int k) {
    int size = sizeList(*head);
    if (k > size || k < 0) {
        printf("Выход за границы списка!\n");
        return;
    }
    if(*head == NULL) {
        return;
    }
    if (k == 0) {
        if ((*head)->next == *head) { // если в списке 1 элемент
            free(*head);
            *head = NULL;
        } else {
            Node* last = (*head)->prev;
            Node* second = (*head)->next;
            last->next = second;
            second->prev = last;
            free(*head);
            *head = second;
        }
    } else {
        Node* current = *head;
        for(int i = 0; i < k; i++) {
            current = current->next;
        }
        Node* left = current->prev;
        Node* right = current->next;
        left->next = right;
        right->prev = left;
        free(current);
    }
}

void pushBack(Node** head, char data) {
    Node* newNode = (Node*)malloc(sizeof(Node));//выделяем память
    newNode->data = data;//присваиваем значение литеры
    if (*head == NULL) {//если "голова" пустая
        *head = newNode;//добавленный элемент - голова списка
        newNode->prev = newNode->next = newNode;//ссылка на самого себя
    } else {// иначе (инверсия pushFront)
        Node* last = (*head)->prev;
        newNode->prev = last;
        newNode->next = *head;
        (*head)->prev = newNode;
        last->next = newNode;
    }
}

void deleteFront(Node** head) { //функция удаления спереди
    if (*head == NULL) { 
        printf("Список пуст!\n");
    } else if ((*head)->next == *head) { //если только один элемент в списке
        free(*head);
        *head = NULL;
    } else {
        Node* last = (*head)->prev; //заопминаем предыдуший и некст
        Node* second = (*head)->next;
        last->next = second; //вычленяем голову и связываем запомнившиеся элементы
        second->prev = last;
        free(*head);
        *head = second; //нвоая голова
    }
}

void deleteBack(Node** head) { //функция удаления сзади
    if (*head == NULL) {
        printf("Список пуст!\n");
    } else if ((*head)->next == *head) { //если только один элемент в списке
        free(*head);
        *head = NULL;
    }else {  // инверсия функции удаления спереди
        Node* last = (*head)->prev;
        Node* second = last->prev;
        second->next = *head;
        (*head)->prev = second;
        free(last);
    }
}

void destroy(Node* head) { //функция очистки 
    if (head == NULL) {
        return;
    } else {
        Node* current = head; //начинаем с головы
        do {
            Node* tmp = current->next; //пока не вернулись к голове, движемся 
            free(current); //освобождаем 
            current = tmp;
        } while (current != head);
    }
}
void func(Node** head, int k) { //функция варианта (swap k-1 элемент с k+1)
    int sizelist = sizeList(*head);
    if (k > sizelist)
    {
        return;
    }else if (k <= sizelist)
    {
        while (k != 0){
            deleteBack(head);
            --k;
        }
        return;
    }
}



void printList(Node* head) { //функция вывода списка
    if (head == NULL) {
        printf("Список пуст!\n");
    } else {
        Node* current = head;
        printf("("); //печатаем скобку для красоты
        do {
            printf("%c", current->data); //двигаемся пока не дошли до головы
            current = current->next;
            if(current != head) { //печатаем запятую
                printf(", ");
            }
        } while (current != head);
        printf(")");
    }
}

int sizeList(Node* head) { //функция вывода размера списка
    if (head == NULL) {
        return 0;
    } else {
        Node* current = head;
        int counter = 0;
        do { //пока не дошли до головы увеличиваем счетчик
            counter++;
            current = current->next;
        } while (current != head);
        return counter;
    }
}
```
main.c
```
#include <stdio.h>
#include <stdlib.h>
#include "list.h"

void printMenu() { // функция меню
    printf("\n");
    printf("0)Выход\n");
    printf("1)Распечатать список\n");
    printf("2)Добавить элемент в начало\n");
    printf("3)Добавить элемент в конец\n");
    printf("4)Добавить элемент по индексу\n");
    printf("5)Удалить элемент в начале\n");
    printf("6)Удалить элемент в конце\n");
    printf("7)Удалить элемент по индексу\n");
    printf("8)Узнать размер списка\n");
    printf("9)Удалить k последних элементов\n");
    printf("\n");
    printf("Введите номер желаемого действия\n");
}

int main(int argc, const char *argv[]) {
    Node* head = NULL; //изначально "голова" = нулю
    int choose = 1;
    char element; // элемент списка
    int k = 1;
    int size = sizeList(head); //размер списка
    int index = 1;
    while(choose) {
        printMenu(); 
        scanf("%d", &choose);
        switch (choose) {
            case 0:
                printf("\nЗавершение работы...\n");
                destroy(head);
                return 0;
            case 1:
                printList(head);
                break;
            case 2:
                printf("Введите литеру: ");
                scanf(" %c", &element); 
                pushFront(&head, element);
                break;
            case 3:
                printf("Введите литеру: ");
                scanf(" %c", &element); 
                pushBack(&head, element);
                break;
            case 4:
                printf("Введите номер индекса: ");
                scanf("%d", &index);
                printf("Введите литеру: ");
                scanf(" %c", &element); 
                pushIndex(&head, element, index);
                break;
            case 5:
                deleteFront(&head);
                printf("Удаление завершено!\n");
                printList(head);
                break;
            case 6:
                deleteBack(&head);
                printf("Удаление завершено!\n");
                printList(head);
                break;
            case 7:
                printf("Введите номер индекса: ");
                scanf("%d", &index);
                deleteIndex(&head, index);
                if (size != sizeList(head)) {
                    printf("Удаление завершено!\n");
                }
                printList(head);
                break;
            case 8:
                size = sizeList(head);
                printf("Размер списка: %d\n", size);
                break;
            case 9:
                printf("Введите значение k:");
                scanf("%d", &k);
                func(&head, k);
                printList(head);
                break;
            default:
                printf("Такого действия не существует\n");
                break;
        }
    }
    return 0;
}
```
Makefile 
```
CC = gcc
CFLAGS = -std=c99 -Wall -Werror
DEBUG = gdb
FILEOUT = list.out
SOURCES = list.c main.c

all:
        $(CC) $(CFLAGS) $(SOURCES)  -o $(FILEOUT)
clean:
        rm -f *.out
debug:
        $(CC) $(CFLAGS) -g $(SOURCES)
        sudo $(DEBUG) $(FILEOUT)
cmp:
        $(CC) $(CFLAGS) $(SOURCES) -o $(FILEOUT)
run:
        ./$(FILEOUT)
```

## 8. Распечатка протокола

```
lockr@lockR:~/projects/labs/fundamentals-of-computer-science-lockr/focs_kp_8$ make all
gcc -std=c99 -Wall -Werror list.c main.c  -o list.out
lockr@lockR:~/projects/labs/fundamentals-of-computer-science-lockr/focs_kp_8$ ./list.out 

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
2
Введите литеру: e

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
2
Введите литеру: t

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
3
Введите литеру: y

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
1
(t, e, y)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
4
Введите номер индекса: 2
Введите литеру: 3

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
4
Введите номер индекса: 1
Введите литеру: v

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
5
Удаление завершено!
(v, e, 3, y)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
6
Удаление завершено!
(v, e, 3)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
1
(v, e, 3)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
7
Введите номер индекса: 1
Удаление завершено!
(v, 3)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
8
Размер списка: 2

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
2
Введите литеру: t

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
3
Введите литеру: e

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
2
Введите литеру: 2

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
2
Введите литеру: 5

0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
1
(5, 2, t, v, 3, e)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
9
Введите значение k:7
(5, 2, t, v, 3, e)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
1
(5, 2, t, v, 3, e)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
9
Введите значение k:4
(5, 2)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
1
(5, 2)
0)Выход
1)Распечатать список
2)Добавить элемент в начало
3)Добавить элемент в конец
4)Добавить элемент по индексу
5)Удалить элемент в начале
6)Удалить элемент в конце
7)Удалить элемент по индексу
8)Узнать размер списка
9)Удалить k последних элементов

Введите номер желаемого действия
0

Завершение работы...
```


## 9. Дневник отладки

| **№** | **Лаб.Или Дом.** | **Дата** | **Время** | **Событие** | **Действие по исправлению** | **Примечание** |
| --- | --- | --- | --- | --- | --- | --- |
| **1** | **Дом.** | **25.05.23** | **13:00** | **Выполнение лаб. работы** | **-** | **-** |

## 10. Замечания автора по существу работы
Codeforces Round 879 (Div. 2)\
[Задача 1834A решена на контесте](https://codeforces.com/contest/1834/submission/210044754)

## 11. Выводы
После выполнения работы, были получены продвинутые навыки обработки строк и бинарных деревьев в языке Си.

<b>Подпись студента:</b> ___________